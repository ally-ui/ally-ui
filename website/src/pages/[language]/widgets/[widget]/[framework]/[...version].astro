---
import type {MDXInstance} from 'astro';
import {Frontmatter, KNOWN_FRAMEWORK_CODES} from '../../../../../config';
import WidgetLayout from '../../../../../layouts/WidgetLayout.astro';
import {compareVersionStr} from '../../../../../utils/version';

interface PathToken {
	language: string;
	widget: string;
	version: string;
}

interface Params {
	widget: string;
	framework: string;
	version?: string | undefined;
}

interface Props {
	page: MDXInstance<Frontmatter>;
	versions: string[];
}

interface StaticPaths {
	params: Params;
	props: Props;
}

export async function getStaticPaths(): Promise<StaticPaths[]> {
	function parsePathToken(filepath: string): PathToken | undefined {
		const tokens = filepath.match(/([\w-]+)\/(\d+\.\d+\.\d+)\/([\w-]+)\.mdx$/);
		if (tokens === null) return undefined;
		if (tokens.length !== 4) return undefined;
		return {
			widget: tokens[1]!,
			version: tokens[2]!,
			language: tokens[3]!,
		};
	}

	function isNotUndefined<TValue>(
		value: TValue,
	): value is Exclude<TValue, undefined> {
		return value !== undefined;
	}

	const content = await Astro.glob<Frontmatter>(
		'../../../../../content/widgets/**/*.mdx',
	);
	const languageToWidgetToVersionPages: Record<
		string,
		Record<string, [string | undefined, MDXInstance<Frontmatter>][]>
	> = {};

	for (const page of content) {
		const pathToken = parsePathToken(page.file);
		if (pathToken === undefined) continue;
		const {language, widget, version} = pathToken;
		const widgetToVersionPages = languageToWidgetToVersionPages[language] ?? {};
		const pages = widgetToVersionPages[widget] ?? [];
		pages.push([version, page]);
		widgetToVersionPages[widget] = pages;
		languageToWidgetToVersionPages[language] = widgetToVersionPages;
	}

	for (const widgetToVersionPages of Object.values(
		languageToWidgetToVersionPages,
	)) {
		for (const versionPages of Object.values(widgetToVersionPages)) {
			versionPages.sort(([a], [b]) => compareVersionStr(a, b));
			const [, latestPage] = versionPages.at(-1)!;
			versionPages.push([undefined, latestPage]);
		}
	}

	return Object.entries(languageToWidgetToVersionPages).flatMap(
		([language, widgetToVersionPages]) =>
			Object.entries(widgetToVersionPages).flatMap(([widget, versionPages]) =>
				KNOWN_FRAMEWORK_CODES.flatMap((framework) =>
					versionPages.map(([version, page]) => ({
						params: {language, widget, framework, version},
						props: {
							page,
							versions: versionPages
								.map(([version]) => version)
								.filter(isNotUndefined),
						},
					})),
				),
			),
	);
}

const {widget, framework} = Astro.params as unknown as Params;
const {page, versions} = Astro.props as Props;
const {file, frontmatter, getHeadings, Content} = page;
---

<WidgetLayout
	file={file}
	frontmatter={frontmatter}
	headings={getHeadings()}
	versions={versions}
>
	<Content widget={widget} framework={framework} versions={versions} />
</WidgetLayout>
